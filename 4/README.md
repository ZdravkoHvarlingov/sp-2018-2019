# Навигация във файлове
(записки към четвъртото упражнение)

Употреба на системното извикване `lseek(2)`.

## `lseek(2)`

    #include <unistd.h>

    off_t lseek(int fd, off_t offset, int whence);

Системното извикване `lseek()` променя текущата позиция на четене или писане в отворения файл (т.е. пореден номер на байт в него, започващ от `0`), асоцииран с файловия дескриптор `fd`.  То ѝ задава стойност `offset`, съобразявайки се с директивата `whence` по следния начин:

* ако стойността на `whence` е `SEEK_SET`, на позицията се задава абсолютна стойност `offset` (т.е. спрямо началото на файла);
* ако стойността на `whence` е `SEEK_CUR`, към текущата позиция се прибавя `offset`;
* ако стойността на `whence` е `SEEK_END`, на позицията се задава абсолютна стойност размерът на файла (т.е. номера на байта след последния) плюс `offset`.

Ако стойността на `whence` е `SEEK_CUR` или `SEEK_END`, е възможно е стойността на `offset` да е отрицателна, при което съответно от текущата позиция или от размера на файла се изважда съответният брой байтове (и на позицията се задава тази стойност).

`lseek()` позволява задаване на позиция след края на файла.  Това не променя директно размера му, но при последващо записване на данни на такава позиция във файла се създава т.нар. *дупка* между предишния край на файла и началото на новозаписаните данни, която представлява поредица от нулеви байтове (`\0`).

При успешно преместване на текущата позиция `lseek()` връща абсолютната стойност на новата позиция.  При грешка `lseek()` връща стойност `-1` и номерът на грешката се задава в `errno`.

## Задачи

1. Напишете програма на C, която приема като аргументи число `N`, `ДУМА` и `ФАЙЛ` и замества съдържанието на файла на позиция `N` (започваща от нула) с подадената като аргумент `ДУМА`.  Ако `N` е отрицателно, позицията се отчита спрямо края на файла (т.е. позицията след последния байт от файла е `-1`).

2. Напишете програма на C, която приема като аргументи числа `M` и `N`, както и `СИМВОЛ` и `ФАЙЛ`, и замества съдържанието на файла между позиции `M` и `N` включително с подадения като аргумент `СИМВОЛ`.  `M` и `N` може да са отрицателни.

3. Напишете програма на C, която приема име на вече съществуващ файл като аргумент, отваря го за писане в края му (използвайки флага `O_APPEND`), премества текущата позиция в началото на файла и накрая записва някакви данни в него.  Къде (на коя позиция) ще се появят тези данни във файла?  Защо?

4. Напишете програма на C, която работи като `cp ФАЙЛ1 ФАЙЛ2`, но копира дупките в първия файл по ефикасен начин (т.е. без да записва чрез `write()` нулевите байтове в тях).

5. Напишете програма на C със следния команден ред: `atomic_append [-l] ФАЙЛ N` (аргументът `-l` не е задължителен, затова е ограден в квадратни скоби).

   Тази програма трябва да отваря подадения като аргумент `ФАЙЛ` (създавайки го, ако не съществува) и да записва `N` на брой байта в него, използвайки отделни извиквания на `write()` за всеки един от тях.  По подразбиране програмата трябва да отваря файла, използвайки флага `O_APPEND`, но ако бъде подаден аргументът `-l`, вместо да използва `O_APPEND`, програмата ще изпълнява `lseek(fileno, 0, SEEK_END)` преди всеки `write()`.

   За да тествате програмата, изпълнете я два пъти едновременно с едни и същи аргументи, без да подавате `-l` като аргумент:

       $ atomic_append f1 1000000 & atomic_append f1 1000000

   Сега повторете експеримента, записвайки в друг файл, но този път подайте `-l` като аргумент:

       $ atomic_append -l f2 1000000 & atomic_append -l f2 1000000

   Проверете размерите на двата файла `f1` и `f2` и обяснете разликите.